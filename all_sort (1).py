# -*- coding: utf-8 -*-
"""all_Sort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o01uLY5xJvr3Tb21ZceXR-J2XtCTdIUK
"""

import random
import time

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def selection_sort(arr):
    for i in range(len(arr)):
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        merge(arr, left_half, right_half)

def merge(arr, left, right):
    i = j = k = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1

    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Ana program
arr_to_sort = [random.randint(1, 100) for _ in range(10)]
print("Orijinal dizi:", arr_to_sort)

choice = input("Hangi sıralama algoritmasını kullanmak istersiniz? (bubble/insertion/selection/merge/heap/quick): ")

start_time = time.time()
if choice == "bubble":
    bubble_sort(arr_to_sort)
elif choice == "insertion":
    insertion_sort(arr_to_sort)
elif choice == "selection":
    selection_sort(arr_to_sort)
elif choice == "merge":
    merge_sort(arr_to_sort)
elif choice == "heap":
    heap_sort(arr_to_sort)
elif choice == "quick":
    quick_sort(arr_to_sort, 0, len(arr_to_sort) - 1)
else:
    print("Geçersiz seçenek!")

end_time = time.time()
elapsed_time = end_time - start_time

print("Sıralanmış dizi:", arr_to_sort)
print(f"{choice.capitalize()} sıralama algoritması {elapsed_time:.6f} saniyede çalıştı.")

arr_to_sort = [random.randint(1, 100) for _ in range(1000)]

# Algoritmaların sürelerini hesaplama
algorithms = {
    "Bubble Sort": bubble_sort,
    "Insertion Sort": insertion_sort,
    "Selection Sort": selection_sort,
    "Merge Sort": merge_sort,
    "Heap Sort": heap_sort,
    "Quick Sort": quick_sort
}

times = {}
for name, algorithm in algorithms.items():
    arr_copy = arr_to_sort.copy()
    start_time = time.time()
    if name == "Quick Sort":
        algorithm(arr_copy, 0, len(arr_copy) - 1)
    else:
        algorithm(arr_copy)
    end_time = time.time()
    times[name] = end_time - start_time

# Süreleri ekrana yazdır
for name, elapsed in times.items():
    print(f"{name} süresi: {elapsed:.6f} saniye")

"""
**Bubble Sort (Kabarcık Sıralama):**
Temel mantık, ardışık elemanları karşılaştırıp, gerektiğinde yer değiştirmektir.
Her geçişte en büyük eleman, dizinin sonuna yerleşir.
Zaman karmaşıklığı: O(n^2) (en kötü durumda).

**Insertion Sort (Ekleme Sıralama):**
Diziyi sıralı ve sırasız kısımlar olarak düşünür.
Sırasızdaki elemanı uygun konuma ekleyerek sıralı kısmı genişletir.
Zaman karmaşıklığı: O(n^2) (en kötü durumda).

**Selection Sort (Seçme Sıralama):**
Dizinin minimum elemanını seçip, sıralı kısma ekler.
Her geçişte en küçük eleman bulunur ve sıralı kısma eklenir.
Zaman karmaşıklığı: O(n^2) (her durumda).

**Merge Sort (Birleştirme Sıralama):**
"Böl ve Yönet" stratejisini kullanır.
Diziyi iki eşit parçaya böler, her parçayı sıralar ve sonra birleştirir.
Zaman karmaşıklığı: O(n log n) (her durumda).

**Heap Sort (Yığın Sıralama):**
Bir max heap (veya min heap) oluşturur.
Heap yapısını kullanarak en büyük elemanı çıkarır ve sıralı kısmı oluşturur.
Her adımda, diziyi bir max heap olarak düşünüp en büyük elemanı kökten çıkarır.
Zaman karmaşıklığı: O(n log n) (her durumda).

**Quick Sort (Hızlı Sıralama):**
Bir pivot eleman seçer ve diziyi pivot etrafında iki alt diziye böler.
Pivot eleman, doğru konumuna yerleştirilir.
Her iki alt dizi için bu işlemi tekrar eder, rekürsif olarak sıralama yapar.
Zaman karmaşıklığı: O(n^2) (en kötü durumda), O(n log n) (ortalama durumda).
"""
